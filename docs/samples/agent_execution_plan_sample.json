{
  "task_summary": "Demonstrate failure vs blocking semantics for unknown tools and dependencies",
  "assumptions": [
    "The executor fails a step when a tool is unknown",
    "Downstream steps are skipped when dependencies are not satisfied",
    "The executor appends a __meta__ record at the end of execution_results"
  ],
  "risks": [
    "If step ordering is incorrect, dependency checks may block execution",
    "If the registry changes, tool availability assumptions may become invalid"
  ],
  "steps": [
    {
      "step_id": "step_1",
      "title": "Attempt an unknown tool to trigger a failure",
      "description": "Call a non-existent tool name to force the executor to mark this step failed.",
      "dependencies": [],
      "deliverable": "A failed execution result with an error message describing unknown tool.",
      "acceptance": "execution_results[step_1].ok=false and execution_results[step_1].error contains 'Unknown tool'.",
      "tool": {
        "name": "no_such_tool",
        "args": {}
      }
    },
    {
      "step_id": "step_2",
      "title": "Downstream step should be skipped due to unmet dependency",
      "description": "This step depends on step_1 and should be skipped when step_1 fails.",
      "dependencies": [
        "step_1"
      ],
      "deliverable": "A skipped execution result with dependency-not-satisfied reason.",
      "acceptance": "execution_results[step_2].skipped=true and reason contains 'dependency not satisfied'.",
      "tool": {
        "name": "get_time",
        "args": {}
      }
    }
  ]
}
